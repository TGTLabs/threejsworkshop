<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>NVA</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/GLTFLoader.js"></script>
		<script>
      // I am a single-line comment
      /* I am a multi-line comment.
      Everything will be comment until */

			// Our Javascript will go here.

      /* ==========================================
              Three.js needs to be initialized
         ========================================== */

      // Create a scene and store this scene object as variable "scene"
      var scene = new THREE.Scene();

      // Create a perspective camera and set to:
      //   a. 75 degree FOV (Field of view)
      //   b. Aspect ratio as screen width divided by screen height (since the entire screen is our canvas)
      //   c. 0.1 unit near clipping
      //   d. 1000 unit far clipping
      //   (note: objects further away from the camera than the value of far or closer than near won't be rendered)
      // and store this camera object as variable "camera"
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			// Set the "camera"'s z axis position to 5.8 unit (Note that the initial position will be 0, 0, 0 that's why x and y are not set)
			camera.position.z = 5.8;

      // Create a WebGL renderer and store this renderer as variable "renderer"
      var renderer = new THREE.WebGLRenderer();

			// These are recommended gamma settings
			renderer.gammaOutput = true;
			renderer.gammaFactor = 2.2;

      // Render in full screen size
      renderer.setSize( window.innerWidth, window.innerHeight );

      // Add render to the page(body)
      document.body.appendChild( renderer.domElement );

      /* ==========================================
                  Let the magic begin
         ========================================== */

			// Earth
			// Original tutorial here: http://blog.mastermaps.com/2013/09/creating-webgl-earth-with-threejs.html

			// Create a SphereGeometry (set as 5 radius, 20 horizontal segaments, 20 vertical segaments) and store this object as "earthGeometry"
			var earthGeometry = new THREE.SphereBufferGeometry( 5, 32, 32 );
			// Load a texture image from file and store this object as "earthTexture"
			var earthTexture = new THREE.TextureLoader().load('assets/earth/earth.jpg');
			// Create a MeshBasicMaterial and set the texture map to be "earthTexture", and then store the object as "earthMaterial"
			var earthMaterial = new THREE.MeshPhongMaterial( { map : earthTexture, transparent: true } );
			// Create a Mesh using "earthGeometry" and "earthMaterial" and store the object as "earth"
			var earth = new THREE.Mesh( earthGeometry, earthMaterial );
			// Not adding to scene here as we will be adding the earth to an anchor object with the sunlight so they can rotate together.

			// Sun
			// Create a soft white directional light to simulate sun light
			var sunlight = new THREE.DirectionalLight( 0x404040, 4 );
			// We set the sunlight position to ( 5, 3, 5 ) to simulate the tilted earth axis
			sunlight.position.set( 5, 3, 5 );
			// Not adding to scene here as we will be adding the sunlight to an anchor object with the earth so they can rotate together.

			// This is a soft ambient light to simulate moon reflection and etc.
			var light = new THREE.AmbientLight( 0x404040, 0.05 );
			scene.add( light );

			// Group
			// Although not scientifically correct, to make it easy, we are grouping together earth and sun light so they turn together to simulate the effect that the space shuttle is orbiting the earth.
			var earthAndSun = new THREE.Group();
			earthAndSun.add( earth );
			earthAndSun.add( sunlight );
			earthAndSun.rotation.z = Math.PI * 0.2;
			scene.add( earthAndSun );

      /* ==========================================
                    Adventure Time!
         ========================================== */
      // TODO: Play around with the settings here, make it bigger, make it smaller, make less segaments, change the texture, save it and refresh the page. Voila!

			// shuttle
			var shuttle = null;
			// We are initiating an object to store the angular velocity, and this object will be modified after each user input, so we can keep track of how fast the shuttle is spinning.
			var shuttleAngularVelocity = {
				x: 0,
				y: 0,
				z: 0
			};
			new THREE.GLTFLoader().load( 'assets/spaceshuttle/scene.gltf', function ( gltf ) {
				// this is a callback function, because loading the model is async, we want the browser to continue work here after it is loaded.
				shuttle = gltf.scene.children[0];
				// This scale looks good.
				shuttle.scale.set( 0.005, 0.005, 0.005 );
				// This position looks good. Don't ask me why.
				shuttle.position.z = 5.1;
				// Rotate the shuttle to the proper angle (idean radian) (Math.PI is 180 degrees)
				/* ==========================================
						 					Do you like MATH?
								Time to get disorientated in 3D!
					 ========================================== */
				// TODO:
				// Knowing that the shuttle will be loaded facing towards the camera
				// What rotation do we put in to the make shuttle point to the top left corner of the screen with the back facing the camera,
				// so it looks like the shuttle is flying towards the top left corner?
				shuttle.rotation.x = Math.PI; // 180
				shuttle.rotation.y = Math.PI; // 180
				shuttle.rotation.z = 0.35 * Math.PI; // 63
				// Don't forget to add the "shuttle" to the "scene".
				scene.add( shuttle );
			},  function ( xhr ) {
				// Report 3d model loading progress here
			}, function ( error ) {
				// Report 3d model loading error here
				console.error( error );
			});

			// We need to register the "keydown" event on document so we get a call when user presses any key down.
			document.addEventListener( 'keydown', function( event ) {
				// this is another usage of callback function is that we do not know when an event will happen and we want to do something only after such event, which is called a "listener".
				// this is a switch block, often used for listing out different stuff to do for differernt conditions
				switch ( event.key ) {
					case "a":
						// Key "a" is pressed down
						// roll to the left
						shuttleAngularVelocity.y += 0.01;
						break;
					case "d":
						// Key "d" is pressed down
						// roll to the right
						shuttleAngularVelocity.y -= 0.01;
						break;
					case "w":
						// Key "w" is pressed down
						// pitch down
						shuttleAngularVelocity.x += 0.01;
						break;
					case "s":
						// Key "s" is pressed up
						// pitch up
						shuttleAngularVelocity.x -= 0.01;
						break;
					case "q":
						// Key "q" is pressed down
						// yaw to the left
						shuttleAngularVelocity.z += 0.01;
						break;
					case "e":
						// Key "e" is pressed down
						// yaw to the right
						shuttleAngularVelocity.z -= 0.01;
						break;
				}
			}, false );

			var animate = function () {
				// Tell the browser that I want the function "animate" to be called again the next frame
				requestAnimationFrame( animate );

				if ( earthAndSun ) {
					// Rotate the "earthAndSun" 0.0001 degree around y and z axis every frame
					earthAndSun.rotation.y += Math.PI * 0.0001;
					earthAndSun.rotation.z += Math.PI * 0.0001;
				}

				if ( shuttle ) {
					shuttle.rotateOnAxis(new THREE.Vector3(1, 0, 0), shuttleAngularVelocity.x);
					shuttle.rotateOnAxis(new THREE.Vector3(0, 1, 0), shuttleAngularVelocity.y);
					shuttle.rotateOnAxis(new THREE.Vector3(0, 0, 1), shuttleAngularVelocity.z);
				}

				/* ==========================================
						 Adventure Time! (Technical Interview)
					 ========================================== */
				// Q: Knowing that:
				//   a. To move the cube to the left for one unit on x axis, you set "cube.position.x = cube.position.x - 1;"
				//   b. To move the cube to the right for one unit on x axis, you set "cube.position.x = cube.position.x + 1;"
				//   c. "Math.random()" returns a random number between 0 (inclusive) and 1 (exclusive);
				// How do you make the cube dance around the screen?
				// (Extra credit) How do you make the cube bounce left and right?
				//
				// A: Write your code here:

				// Tell the "renderer" to render a new image of the "scene", from "camera"
				renderer.render( scene, camera );
			};

			// Call "animate" for the first time.
			animate();
		</script>
	</body>
</html>
